<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>0.springCloud的演示概述 - Joplin Note By BlueLvRen</title>
  </head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">Joplin Note By BlueLvRen</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">0.springCloud的演示概述</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1684891335062"
                  >2023-05-24 09:22</time
                ></span
              >
              <span
                >Updated At：<time datetime="1684910028593"
                  >2023-05-24 14:33</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><blockquote>
<p>参考：<a title="https://www.bilibili.com/video/BV1ez4y1D7w6" href="https://www.bilibili.com/video/BV1ez4y1D7w6">https://www.bilibili.com/video/BV1ez4y1D7w6</a></p>
</blockquote>
<p>A开了一家饭店，厨师、跑堂、收银全是自己一个人干，并且开发了一套管理系统管理饭店。<br />
随着饭店规模扩大，A开始忙不过来，招聘了一个厨师、跑堂、收银、程序员来替自己工作。</p>
<blockquote>
<p>多个微服务对外提供访问</p>
</blockquote>
<p>随着饭店规模扩大，员工也不够用了，A继续招人，但是出现了新的问题，客人们不知道叫哪个跑堂点菜，于是A决定使用“服务注册中心”——A为店里的每个员工和餐桌都配备了一个pad，员工把自己的情况、能完成的任务都告诉Eureka，客人点餐也通过pad而不是指定员工，点完菜后pad将客人的请求发送给厨师，厨师炒完菜后告诉跑堂，跑堂将菜端给客人。</p>
<blockquote>
<p>使用服务注册中心进行管理，代表产品为Netflix的Eureka</p>
</blockquote>
<p>新的问题又出现了，客人点完菜后有俩厨师，如何决定让谁炒菜，于是A决定使用“负载均衡”机制——以轮询方案为例，客人叫的第一个菜让第一个厨师炒，第二个菜让第二个厨师炒，第三个菜让第一个厨师炒，以此类推；如果厨师之间效率有差别，还可以灵活规定轮到厨师炒菜的机会。</p>
<blockquote>
<p>使用负载均衡进行管理，代表产品为Netflix的Ribbon，它使用轮询机制</p>
</blockquote>
<p>新的问题又出现了，程序员发现这些服务之间的调用过于复杂，需要写一堆代码与其他微服务建立网络连接，然后调用复杂的请求，接着发送请求过去，最后再根据对方返回的响应结果，再写一大堆代码进行处理，如何简化代码，于是程序员决定使用“服务调用简化器”。</p>
<blockquote>
<p>使用服务调用简化器进行服务调用的简化，代表产品为Netflix的Feign，只需要用注解定义一个叫做FeignClient的接口，然后就可以像调用本地方法一样方便了，Feign会在底层根据注解，自己把建立连接、构造请求、发送请求、获取响应、解析响应这些脏活累活都给干了。</p>
</blockquote>
<p>某天用餐高峰期，厨房的天然气总阀坏了，厨师无法炒菜，餐桌上的客人在等待上餐，而店外的客人还在不断进入，最后导致饭店陷入瘫痪状态。一旦某个微服务因为各种各样的原因不能提供服务，是否应该迅速提供一个友好的返回提示，比如告诉饭店内的客人不要再等待，饭店外的客人不要再进入了？为了防止类似的情况发生，A决定使用“服务降级与熔断机制”。</p>
<blockquote>
<p>使用服务降级与熔断机制来处理服务器高压的情况，代表产品为Netflix提供的Hystrix，Hystrix会创建许多小的线程池，比如厨师是一个线程池，跑堂是一个线程池等，他们共同对外提供服务。当出现某些特殊情况导致厨师无法提供炒菜服务了，客人点菜的时候直接返回不能炒菜的友好回答，而不是等待很久什么结果也返回不了，这就是熔断。厨师还可以安抚性地给客人一小碟事先已经炒好的花生米，但是菜是炒不了了，这就是降级。</p>
</blockquote>
<p>A开始开分店，并且为自己的系统增加外卖业务，随着而来是新的问题，客户登录A的系统进行点餐时，需要自己去选饭店地址，但每个店的人流量可能不同，造成了资源分布的极不平均，为了解决这个问题，A决定在整个系统的外面加一层“网关”。</p>
<blockquote>
<p>使用网关进行管理，代表产品为Netflix的Zuul，客人需要先在A的系统里注册一个账号，当他想点外卖的时候，只需要告诉系统他想吃什么，Zuul根据客人点菜的时间、种类、位置以及现在分店的繁忙程度等信息来自动查找哪个分店更适合为他服务。</p>
</blockquote>
<p>某天A到外地考察，学会了一道新菜想要让自己的厨师们也学会，如果到每个分店去教太耗费A的精力，不如A将炒菜的过程录下来，上传到系统里再打电话通知每个厨师自己去观看，不仅可以节省A的时间，厨师也可以在自己不忙的时间去自主学习，于是A决定给系统增加一个“配置中心”。</p>
<blockquote>
<p>使用配置中心进行配置，代表产品为SpringCloud提供的Config</p>
</blockquote>
<p>A学到了更多的新菜，但是再一个个打电话通知每个厨师去学习过于麻烦，于是他决定使用“总线”机制。</p>
<blockquote>
<p>使用总线进行通知管理，代表产品为SprignCloud的Bus，总线使用了利用了消息机制，当A上传好做菜视频的时候，系统自动给所有厨师发送消息，厨师们收到广播推送的消息时就可以去自主学习。Bus支持的消息队列有RabbitMQ和kafka。</p>
</blockquote>
<p>之后饭店规模不断扩大，但是再也没出过大的问题。可喜可贺，可喜可贺。</p>
<hr />
<p>以下为原来的整理</p>
<p>A开了一家饭店，厨师、跑堂、收银全是自己一个人干，并且开发了一套管理系统管理饭店。</p>
<p>随着饭店规模扩大，A开始忙不过来，招聘了一个厨师、跑堂、收银、程序员来替自己工作，对外提供服务。</p>
<p>随着饭店规模扩大，员工也不够用了，A继续招人，但是出现了新的问题，客人们不知道叫哪个跑堂点菜，于是A决定上一套“服务注册中心”来管理。</p>
<p>通过使用Netflix提供的Eureka技术，解决了服务注册中心的问题。A为店里的每个员工和餐桌都配备了一个pad，员工把自己的情况、能完成的任务都告诉Eureka，客人点餐也通过pad而不是指定员工，点完菜后pad将客人的请求发送给厨师，厨师炒完菜后告诉跑堂，跑堂将菜端给客人。</p>
<p>新的问题又出现了，客人点完菜后有俩厨师，如何决定让谁炒菜，于是A决定使用“负载均衡”机制。</p>
<p>通过使用Netflix提供的Ribbon，解决了负载均衡的问题。Ribbon使用轮询机制，客人叫的第一个菜让第一个厨师炒，第二个菜让第二个厨师炒，第三个菜让第一个厨师炒，以此类推。如果厨师之间效率有差别，还可以灵活规定轮到厨师炒菜的机会。</p>
<p>新的问题又出现了，程序员发现这些服务之间的调用过于复杂，需要写一堆代码与其他微服务建立网络连接，然后调用复杂的请求，接着发送请求过去，最后再根据对方返回的响应结果，再写一大堆代码进行处理，如何简化代码，于是程序员决定使用“服务调用简化器”。</p>
<p>通过使用Netflix提供的Feign，只需要用注解定义一个叫做FeignClient的接口，然后就可以像调用本地方法一样方便了，Feign会在底层根据注解，自己把建立连接、构造请求、发送请求、获取响应、解析响应这些脏活累活都给干了。</p>
<p>某天用餐高峰期，厨房的天然气总阀坏了，厨师无法炒菜，餐桌上的客人在等待上餐，而店外的客人还在不断进入，最后导致饭店陷入瘫痪状态。一旦某个微服务因为各种各样的原因不能提供服务，是否应该迅速提供一个友好的返回提示，比如告诉饭店内的客人不要再等待，饭店外的客人不要再进入了？为了防止类似的情况发生，A决定使用“服务降级与熔断机制”。</p>
<p>通过使用Netflix提供的Hystrix，Hystrix会创建许多小的线程池，比如厨师是一个线程池，跑堂是一个线程池等，他们共同对外提供服务。当出现某些特殊情况导致厨师无法提供炒菜服务了，客人点菜的时候直接返回不能炒菜的友好回答，而不是等待很久什么结果也返回不了，这就是熔断。厨师还可以安抚性地给客人一小碟事先已经炒好的花生米，但是菜是炒不了了，这就是降级。</p>
<p>A开始开分店，并且为自己的系统增加外卖业务，随着而来是新的问题，客户登录A的系统进行点餐时，需要自己去选饭店地址，但每个店的人流量可能不同，造成了资源分布的极不平均，为了解决这个问题，A决定在整个系统的外面加一层“网关”。</p>
<p>通过使用Netflix提供的Zuul，客人需要先在A的系统里注册一个账号，当他想点外卖的时候，只需要告诉系统他想吃什么，Zuul根据客人点菜的时间、种类、位置以及现在分店的繁忙程度等信息来自动查找哪个分店更适合为他服务。</p>
<p>某天A到外地考察，学会了一道新菜想要让自己的厨师们也学会，如果到每个分店去教太耗费A的精力，不如A将炒菜的过程录下来，上传到系统里再打电话通知每个厨师自己去观看，不仅可以节省A的时间，厨师也可以在自己不忙的时间去自主学习，于是A决定给系统增加一个“配置中心”。</p>
<p>这个配置中心使用了SpringCloud提供的Config。</p>
<p>A学到了更多的新菜，但是再一个个打电话通知每个厨师去学习过于麻烦，于是他决定使用“总线”机制。</p>
<p>总线使用了SprignCloud提供的Bus利用了消息机制，当A上传好做菜视频的时候，系统自动给所有厨师发送消息，厨师们收到广播推送的消息时就可以去自主学习。Bus支持的消息队列有RabbitMQ和kafka。</p>
<p>之后饭店规模不断扩大，但是再也没出过大的问题。可喜可贺，可喜可贺。</p>
</div>
      </article>
    </div>
  </body>
</html>
